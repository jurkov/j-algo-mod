\newcommand{\code}[1]{\lstinline$#1$}

\section{Implementieren eines neuen Moduls}
Hier sollen nur die technischen Schritte angegeben sein, die nötig sind, ein neues Modul für \jalgo korrekt und vollständig aufzusetzen und in das Hauptprogramm zu integrieren. Es wird vorausgesetzt, dass der Entwickler selbst ein Konzept seines Moduls entwickelt, insbesondere, was Details der Visualisierung betrifft.

Es folgen fünf Abschnitte. Im ersten wird der Teil erklärt, der für das Implementieren eines neuen Moduls minimal notwendig ist. Der zweite Abschnitt enthält Erklärungen zur Funktionsweise der Pluginstruktur von \jalgo, und was der Entwickler für korrekte Erkennung des Moduls zu beachten hat. Der dritte Abschnitt zeigt, wie die Ressourcen des zu implementierenden Moduls organisiert sein sollten. Der vierte Abschnitt erklärt, wie die Dateien der Online-Hilfe für das Modul zu organisieren sind und der fünfte Abschnitt schließlich zeigt die hauptprogrammseitige Schnittstelle zwischen Modul und Hauptprogramm. Im folgenden wird abkürzend für "`Das zu implementierende Modul"' nur "`Das Modul"' geschrieben.

\subsection{Grundimplementierung}
Der Code für das Modul wird im Paket \verb|org.jalgo.module.|\textsc{<Modulkürzel>} abgelegt. Das Modulkürzel sollte aussagekräftig, jedoch relativ kurz gehalten sein. Es wird später im Code oft benötigt, wenn es um Ressourcen-Zugriffe geht.\\
Eine schlechte Wahl wären also zum Beispiel \verb|dijkstrasShortestPathAlgorithm| oder vielleicht \verb|syntaxDiagramsAndEBNF|.

Es gibt zwei Schnittstellen, um das Hauptprogramm mit einem Modul zu vernetzen. Die erste, modulseitige, Schnittstelle besteht aus zwei Klassen. Jedes Modul muss eine Verbindungseinheit und eine Informationseinheit anbieten. Die Verbindungseinheit muss abgeleitet sein von \verb|org.jalgo.main.AbstractModuleConnector|. Hier sind Methoden zu implementieren, die die Interaktion des Moduls mit dem Hauptprogramm spezifizieren. Für Details dazu sollte die API-Dokumentation von \jalgo konsultiert werden. Nachfolgend ist die Schnittstelle von \verb|AbstractModuleConnector| abgebildet.\\[0.25cm]
\textbf{Achtung!} Die Verbindungseinheit muss sich an eine Namenskonvention halten: Paket und Name der Klasse muss \verb|org.jalgo.module.|\textsc{<Modulkürzel>}\verb|.ModuleConnector| lauten. Dies ist ein notwendiger Teil der Pluginstruktur von \jalgo. Für Details dazu lesen Sie bitte den nächsten Abschnitt.
\newpage
\begin{verbatim}
public abstract class AbstractModuleConnector {
    public abstract void init();
    public abstract void run();
    public abstract void setDataFromFile(ByteArrayInputStream data);
    public abstract ByteArrayOutputStream getDataForFile();
    public abstract void print();

    public boolean close();

    public final IModuleInfo getModuleInfo();
    public enum SaveStatus {
        NOTHING_TO_SAVE,
        NO_CHANGES,
        CHANGES_TO_SAVE
    }
    public final SaveStatus getSaveStatus();
    public final void setSaveStatus(SaveStatus status);
    public final void setSavingBlocked(boolean blocked);
    public final boolean isSavingBlocked();
    public final String getOpenFileName();
    public final void setOpenFileName(String filename);
}
\end{verbatim}

Die Informationseinheit ist dazu da, Informationen über das Modul bereitzustellen, die dem Benutzer entsprechend aufbereitet dargeboten werden, wenn er ein Modul zur Benutzung auswählen will. Sie muss das Interface \verb|org.jalgo.main.IModuleInfo| implementieren. Für Details dazu sei hier wieder auf die API-Dokumentation von \jalgo verwiesen. Nachfolgend ist die Schnittstelle von \verb|IModuleInfo| abgebildet.
\begin{verbatim}
public interface IModuleInfo {
    public String getName();
    public String getVersion();
    public String getAuthor();
    public String getDescription();
    public URL getLogoURL();
    public String getLicense();
    public URL getHelpSetURL();
}
\end{verbatim}
\textbf{Achtung!} Die Informationseinheit muss sich an eine Namenskonvention halten: Name und Paket der Klasse muss \verb|org.jalgo.module.|\textsc{<Modulkürzel>}\verb|.ModuleInfo| lauten. Dies ist notwendiger Teil der Pluginstruktur von \jalgo.\\
Weiterhin hat die Informationseinheit das \textbf{Singleton}-Entwurfsmuster zu implementieren mit der Zugriffsmethode
\verb|public static IModuleInfo getInstance();|\\
Als Klassenmethode kann diese nicht in das Interface \verb|IModuleInfo| aufgenommen werden. Es sei jedoch ausdrücklich darauf hingewiesen, dass das Fehlen dieser Methode dazu führt, dass das Modul nicht korrekt erkannt wird und dass Laufzeitfehler beim Starten des Programmes auftreten.

Als Beispielcode ist ein minimalistisches Modul implementiert namens \verb|testModule|. Es ist ein korrekt implementiertes Modul, jedoch hat es keinerlei Funktionalität. Der Entwickler kann den Code bei Bedarf als Skelett zum Aufsetzen eines neuen Moduls nehmen. Zum aktuellen Zeitpunkt existieren für \jalgo 2 Module: \textbf{AVL-Bäume} und \textbf{Dijkstra}. Es sei dem Entwickler freigestellt, diese als Anleihe zu nehmen.\\[0.5cm]
Mit diesen beiden Klassen ist die modulseitige Schnittstelle fertiggestellt. Damit das Modul als solches auch vom Hauptprogramm erkannt wird, ist noch ein Schritt notwendig.

\subsection{Pluginstruktur von \jalgo}
An dieser Stelle scheint es angebracht, kurz die Pluginstruktur von \jalgo zu erläutern. In der Distribution wird das Hauptprogramm in ein JAR-Archiv verpackt. Es muss unabhängig von den Modulen sein. Daher wird auch jedes Modul in ein eigenes JAR-Archiv verpackt mit allem, was zu diesem Modul gehört: Code und Ressourcendateien. Dies garantiert, dass bei Erscheinen eines neuen Modules nur das entsprechende JAR-Archiv vom Benutzer heruntergeladen werden muss.\\[0.25cm]
\textbf{Achtung!} Die JAR-Archive für die Module müssen als Namen das Modulkürzel tragen und im Ordner \verb|runtime/modules| liegen. Nur so kann das Modul vom Hauptprogramm erkannt werden.\\[0.25cm]
Während der Laufzeit wird zum Start des Hauptprogramms der Ordner \verb|runtime/modules| nach JAR-Archiven durchsucht. Dabei wird der Name des Archives als Paketname angenommen, und es wird in jedem Archiv nach den beiden Verbindungsklassen (siehe oben) gesucht:\\
\verb|org.jalgo.module.|\textsc{<Archivname>}\verb|.ModuleConnector| und\\
\verb|org.jalgo.module.|\textsc{<Archivname>}\verb|.ModuleInfo|\\
Sind diese korrekt implementiert, wird das Modul in die Liste der installierten Module aufgenommen und kann vom Benutzer ausgewählt werden.

Der Entwickler hat also nun noch eine leere Datei mit dem Namen \textsc{<Modulkürzel>}\verb|.jar| im Ordner \verb|runtime/modules| zu erstellen. Wird \jalgo aus der Entwicklungsumgebung ge\-startet, kann das Modul nun aufgerufen werden.
\newpage

\subsection{Organisation der Ressourcen}
Sicher soll das Modul irgendwelche Ressourcendateien halten, wie zum Beispiel Icons oder ausgelagerte Algorithmentexte.

Da, wie erwähnt, zur Laufzeit das Modul in einem JAR-Archiv vorliegt, kann auf die Ressourcen nur über den Klassenlader zugegriffen werden, indem die Methoden\\ \verb|getClass().getResource(String)| (liefert eine URL) oder\\ \verb|getClass().getResourceAsStream(String)| (liefert einen InputStream)\\
verwendet werden. Es erweist sich als vorteilhaft, wenn die Pfade zu den Ressourcendateien nicht direkt im Code verankert werden, sondern in einer externen Textdatei abgelegt werden. Um einen einfachen Ressourcenzugriff zu ermöglichen, bietet das Hauptprogramm mit der Klasse \verb|org.jalgo.main.util.Messages| die Methode\\
\verb|getResourceURL(String bundleKey, String key)|\\
an, welche direkt die URL einer Ressource zurückgibt. Der erste Parameter ist der Schlüssel, mit welchem das Ressourcenpaket ausgewählt wird, aus dem der Pfad zu entnehmen ist. Dies ist wieder das Modulkürzel, also der Hauptpaketname, wenn moduleigene Ressourcen geladen werden sollen, und \verb|main|, wenn Ressourcen des Hauptprogramms, z.B. Standard-Icons verwendet werden sollen. Der zweite Parameter ist der Schlüssel der Ressource. Dafür ist im Hauptpaket des Moduls eine Textdatei zu erstellen, in welcher Ressourcenpfade zu Schlüsseln zugeordnet werden. Es sei als Beispiel auf die existierenden Dateien von Hauptprogramm und den bestehenden Modulen verwiesen.\\[0.25cm]
\textbf{Achtung!} Die Textdatei mit den Ressourcenpfaden muss einer Namenskonvention folgen: Sie hat den Titel \verb|res.properties| zu tragen und muss im Hauptpaket des Moduls liegen. Anderenfalls wird sie von der Klasse \verb|Messages| nicht gefunden.\\[0.25cm]
Die Ressourcendateien selbst werden im Ordner \verb|res/module/|\textsc{Modulkürzel} abgelegt. Wird unter Eclipse programmiert, ist dieser Ordner unter "`Projekteinstellungen"'->"`Libraries"'-> \mbox{"`Add Class Folder..."'} hinzuzufügen, damit die Ressourcen in der Entwicklungsumgebung freigegeben sind.\\
Um Namenskonflikten unter den Ressourcendateien vorzubeugen (letzlich liegen alle Ressourcenpfade hinter \verb|res/main/| und \verb|res/module/|\textsc{<Modulkürzel>}\verb|/| auf dem Klassenpfad), empfiehlt es sich, im angelegten Ressourcenordner eine angemessene Struktur zu entwickeln, so zum Beispiel einen Unterordner \textsc{<Modulkürzel>}\verb|_pix| für Bilddateien. Jetzt kann auch ein Dateiname wie \verb|icon.gif| ohne Probleme verwendet werden.\vspace{0.5cm}

\jalgo ist ein Programm, welches mehrere Sprachen unterstützt. Zum aktuellen Zeitpunkt sind sämtliche Programmteile in Deutsch und Englisch verfügbar. Dem Entwickler wird nahegelegt, auch das neue Modul in diesen Sprachen zu veröffentlichen. Dazu ist es notwendig, alle Zeichenketten, die dem Benutzer dargeboten werden sollen, in externen Textdateien zu speichern. Auch für den einfachen Zugriff auf diese Zeichenketten bietet die Klasse \verb|org.jalgo.main.util.Messages| eine Methode an:\\
\verb|getString(String bundleKey, String messageKey)|\\
Die Verwendung dieser Methode erfolgt analog zu der oben erwähnten Methode für die Ressourcen.\newpage
\textbf{Achtung!} Die Textdatei mit den ausgelagerten Zeichenketten muss einer Namenskonvention folgen: Auch sie hat die Endung \verb|.properties| zu tragen. Der Name der Datei ist einfach das Kürzel der Sprache, für welche sie Zeichenketten enthält. Für deutsch also \verb|de.properties|, für englisch \verb|en.properties|. Auch diese Textdateien haben im Hauptpaket des Moduls zu liegen.\\[0.25cm]
Liegen die Textdateien korrekt vor, so wird vom Hauptprogramm automatisch auf die eingestellte Sprache umgestellt. Der Modulentwickler muss hierzu nichts mehr beachten.\\
Auch hier wieder sei als Beispiel auf die existierenden Dateien von Hauptprogramm und Modulen verwiesen.\vspace{0.5cm}

Letzlich sei noch erwähnt, dass jedes Modul die Möglichkeit hat, persistente Benutzereinstellungen anzubieten. Will der Modulentwickler solche Einstellungen einbauen, so muss eine Textdatei mit Zuordnungen zwischen Schlüsseln und Werten angelegt werden. Es sind hier alle Einstellmöglichkeiten als Schlüssel zu erwähnen; die zugeordneten Werte sind jeweils die Default-Werte für die entsprechenden Einstellungen.\\[0.25cm]
\textbf{Achtung!} Die Textdatei mit den Default-Einstellungen muss einer Namenskonvention folgen: Sie muss den Namen \textsc{<Modulkürzel>}\verb|.prefs| tragen und im Ressourcenverzeichnis des Moduls (\verb|res/|\textsc{<Modulkürzel>}\verb|/|) liegen. Außerdem muss ein Schlüssel namens "`Version"' in der Datei stehen, dessen Wert die Version der Einstellungsdatei angibt. Wird in einer späteren Version etwas am Bestand der Schlüssel geändert, gewährleistet der geänderte Wert von "`Version"', dass beim Benutzer die Einstellungsdatei neu erstellt wird und an die neuen Einstellungen angepasst wird.\\[0.25cm]
Es wird als Beispiel auf die Dateien \verb|main.prefs| des Hauptprogramms und \verb|avl.prefs| des Moduls AVL-Bäume verwiesen.\\
Zugegriffen wird auf die persistenten Einstellungen über die Klasse\\ \verb|org.jalgo.main.util.Settings|\\
Für Details ist die API-Dokumentation von \jalgo zu konsultieren. Nachfolgend ist der relevante Teil von \verb|Settings| abgebildet:
\begin{verbatim}
public class Settings {

    public static boolean getBoolean(String resourceKey, String settingKey);
    public static void setBoolean(String resourceKey, String key,
        boolean value);
    public static String getString(String resourceKey, String key);
    public static void setString(String resourceKey, String key,
        String value);
}
\end{verbatim}
Wie schon beim Zugriff auf Ressourcenpfade und ausgelagerte Zeichenketten gibt der erste Parameter jeder Methode hier an, in welcher Einstellungsdatei die Einstellmöglichkeit gesucht werden soll. Dies ist für modulspezifische Einstellungen wieder das Modulkürzel. Es ist aber auch möglich, an die Einstellungen des Hauptprogramms zu gelangen mittels des \verb|resourceKey|s \verb|main|.
\newpage

\subsection{Organisation der Hilfe-Dateien}
Dem Entwickler wird angeraten, ebenfalls eine Online-Hilfe zu seinem Modul zu erstellen. Die Online-Hilfe von \jalgo nutzt die Technologie von JavaHelp 2.0. An dieser Stelle kann lediglich ein kleiner Einblick in den Umfang dieses System ermöglicht werden, und es wird vor allem auf die \href{http://java.sun.com/products/javahelp/}{Support-Seiten von Sun} und \href{http://www.knopf.com/resources/help/javahelp.html}{Tutorials} verwiesen.\\
Es folgen 5 Abschnitte. Der erste gibt einen groben Überblick über die für JavaHelp notwendigen Ressourcen. Die Teile 2 bis 4 befassen sich dagegen mit einzelnen Ansichten, mit denen der Zugriff auf die Hilfetexte angenehmer gestaltet werden kann. Zum Schluss wird im letzten Abschnitt noch auf die Einbettung der Hilfe in \jalgo eingegangen.\\
\textbf{Hinweis!} Beispieldateien zur Hilfe sind in den Ressourcen des Hauptprogrammes im Ordner \verb|res/main/help| zu finden. Hier finden sich auch CSS Stylesheets und die config-Datei für die Volltextsuche.

\subsubsection{Überblick}
Bei JavaHelp handelt es sich um eine Betriebssystem-unabhängige Technologie, die in einem Java-basierten Browser HTML-Dateien anzeigen kann. Sie bietet die Möglichkeit, über Ansichten wie Inhaltsverzeichnis, Indexübersicht, Favoriten und Volltextsuche den Zugriff auf die Hilfe zu beschleunigen. Grundlegend für eine mit JavaHelp konstruierte Hilfe sind zwei Dateien.
\begin{itemize}
	\item Die erste ist das sogenannte \textbf{HelpSet}. Diese Datei vereinigt alle für die Hilfe wichtigen Daten und dient der Applikation als eine Art Kontaktdatei. Hier wird unter anderem festgelegt, welche Ansichten die Hilfe unterstützen soll und welche Dateien dafür benutzt werden. Außerdem wird hier die Map-Datei festgelegt.
	\item Die \textbf{Map-Datei} ist ein Liste von Schlüssel-URL-Zuordungen. Alle von der Hilfe benötigten Resourcendateien, wie HTML- oder Bilddateien, werden hier aufgelistet und einem Schlüssel zugeordnet. In den Dateien für die einzelnen Ansichten werden anschließend nur noch Schlüssel als Verweis auf bestimmte Ressourcen verwendet.
\end{itemize}
Neben diesen beiden wichtigen Metadateien besitzt jede Ansicht eine oder mehrere beschreibende Dateien. Dazu jetzt mehr.

\subsubsection{Inhaltsverzeichnis}
Das Inhaltsverzeichnis (Table Of Contents) ermöglicht einen schnellen inhaltsbezogenen Zugriff auf spezielle Hilfethemen und ist daher ungemein praktisch. Aus diesem Grund ist es für eine Hilfe unersetzlich. Die Struktur des Verzeichnisbaumes wird in einer XML-Datei beschrieben, die traditionell den Namen \textsc{<Modulkürzel>}\verb|TOC.xml| trägt. Die genaue Struktur einer solchen Datei lässt sich am besten am Beispiel der Hilfedateien des Hauptprogramms und der bestehenden Module ergründen und wird hier nicht weiter beleuchtet.

\subsubsection{Indexübersicht}
Die Indexübersicht gewährt ähnlich dem Inhaltsverzeichnis einen Überblick über die verschiedenen Hilfethemen. Doch ist sie im allgemeinen alphabetisch geordnet. Auch die Indexübersicht wird durch eine XML-Datei beschrieben. Traditionell ist diese mit dem Namen \mbox{\textsc{<Modulkürzel>}}\verb|Index.xml| betitelt. Auch hier sei bezüglich der Struktur dieser Datei ein Blick in die bestehenden Dateien der Module und des Hauptprogramms ans Herz gelegt.

\subsubsection{Volltextsuche}
Die Volltextsuche ist ein sehr hilfreiches Feature, welches es erlaubt, den gesamten Text der Hilfe nach bestimmten Wörtern zu durchsuchen. Das Erstellen einer solchen Suchoption gestaltet sich nicht so einfach wie bisher und es werden mehrere Dateien dafür verwendet, die im allgemeinen in einem Ordner namens \verb|JavaHelpSearch| des JavaHelp-Ordners abgelegt werden. Im HelpSet wird zu dem auch nur auf diesen Ordner verwiesen und nicht auf eine bestimmte Datei.\\
JavaHelp bietet für die Erzeugung einer Suchengine einen Konsolenbefehl, der alle notwendigen Dateien erzeugt. Der sogenannte \textbf{jhindexer}-Befehl wird im Ordner ausgeführt, in dem das HelpSet zu finden ist. Er durchläuft die HTML-Dateien und vergibt für jedes Wort einen Index. Später wird mit Hilfe dieser das Wort wieder gefunden. Nun ist es ratsam bestimmte Wörter, wie "`eine"', "`keine"', "`mit"' oder "`oder"', aus der Indexierung auszuklammern. Diese sogenannten \textbf{Stopwords} werden in einem config-File aufgelistet und \textbf{jhindexer} übergeben.\\[0.25cm]
Der Befehl hat dann die folgende Form:\\
\verb|jhindexer -c|\textsc{ <config-Datei> <Pfad der HTML-Dateien>}\\[0.25cm]
ein Beispiel: \\
\verb|jhindexer -c|\textsc{ /JavaHelpSearch/config.ini ../html/data}\\[0.25cm]
\textbf{Hinweis!} Der jhindexer-Befehl ist weitaus umfangreicher und es wird empfohlen, alles weitere im JavaHelpUserGuide (jhug.pdf) nachzuschlagen.

\subsubsection{Einbettung von JavaHelp in \jalgo}
Nachdem nun ein wesentlicher Überblick über die Dateien und Ressourcen von JavaHelp entstanden sein sollte, wird im kommenden Abschnitt auf die Einbettung dieser in die Umgebung von \jalgo eingegangen.\\
Grundlegend besteht keine Namenskonvention, die unbedingt eingehalten werden muss. Nur empfiehlt es sich, ausdrucksstarke Namen sowohl für die Datei des HelpSets als auch für Map- und Ansichtsdateien zu verwenden. Das HelpSet sammelt alle wichtigen Dateinamen, und es ist nur ausschlaggebend, wie diese Datei benannt wird. Die bestehenden Module und das Hauptprogramm folgen hier der folgenden Namenskonvention: \textsc{<Modulkürzel>}\verb|_help.hs|.\\
Um die Hilfe schließlich aus dem \jalgo - Hauptprogramm aufrufbar zu machen, wird die Methode \verb|org.jalgo.module.|\textsc{<Modulkürzel>}\verb|.ModuleInfo.getHelpSetURL()| genutzt. Diese liefert den Pfad der HelpSet-Datei. Da es sich bei dem HelpSet um eine Ressource von \jalgo handelt, wird empfohlen, die Methode \verb|getResourceURL(String bundleKey, String key)| der Klasse \verb|org.jalgo.main.util.Messages| wie beschrieben zu nutzen.

\newpage
\subsection{Schnittstelle zum Hauptprogramm}
Die zweite erwähnte Schnittstelle ist die auf Seiten des Hauptprogramms, namentlich die Klasse \verb|org.jalgo.main.gui.JAlgoGUIConnector|. Der Entwickler hat hier nichts zu implementieren, jedoch hat er Kenntnis von dieser Schnittstelle zu haben. Hierüber laufen alle Anfragen, die das Modul an die graphische Oberfläche des Hauptprogramms richtet. Für Details dazu sei auf die API-Dokumentation von \jalgo verwiesen. Nachfolgend ist die Schnittstelle von \verb|JAlgoGUIConnector| abgebildet. Gerade die letzten 3 Methoden sind interessant, um an die moduleigenen GUI-Komponenten zu gelangen.
\begin{verbatim}
public class JAlgoGUIConnector {

    public static JAlgoGUIConnector getInstance();

    public void saveStatusChanged(AbstractModuleConnector moduleInstance);
    public void showErrorMessage(String msg);
    public void showWarningMessage(String msg);
    public void showInfoMessage(String msg);
    public int showConfirmDialog(String question, int optionType);
    public void setStatusMessage(String msg);
    public String showOpenDialog(boolean openAsJAlgoFile,
                                 boolean useCurrentModuleInstance);
    public AbstractModuleConnector newModuleInstanceByName(String moduleName);

    public JComponent getModuleComponent(AbstractModuleConnector module);
    public JMenu getModuleMenu(AbstractModuleConnector module);
    public JToolBar getModuleToolbar(AbstractModuleConnector module);
}
\end{verbatim}
Diese Klasse implementiert das \textbf{Singleton}-Entwurfsmuster. Somit kommt man über die Zugriffsmethode \verb|getInstance()| an die Instanz.
\newpage