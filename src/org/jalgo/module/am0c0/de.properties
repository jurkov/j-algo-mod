Add.0=Der Datenkeller enthält weniger als zwei Elemente!
Add.1=Falls <i>d</i>=<i>d</i>.1:<i>d</i>.2:<i>d</i>.3: ... :<i>d</i>.n mit n \u2265 2, dann (<i>m</i>+1,(<i>d</i>.2+<i>d</i>.1):<i>d</i>.3: ... :<i>d</i>.n,<i>h</i>, <i>inp</i>, <i>out</i>)
AddressSolver.0=StubTrans Addresse darf nicht NULL sein!
AM0InputDialog.0=Neue AM Konfiguration
AM0InputDialog.1=Befehlszähler
AM0InputDialog.12=+
AM0InputDialog.13=-
AM0InputDialog.14=<html>Gib hier eine neue AM Konfiguration ein.<br> Benutze ':' um die Werte im Datenkeller zu trennen<br>und ',' auf dem Ein- und Ausgabeband.<br><br><html>
AM0InputDialog.15=OK
AM0InputDialog.16=Abbrechen
AM0InputDialog.17=Intitiale Konfiguration
AM0InputDialog.18=Diese Eingabe für den Hauptspeicher ist nicht korrekt. Er darf nicht leer sein!\n
AM0InputDialog.19=Diese Eingabe für den Hauptspeicher ist nicht korrekt.\n
AM0InputDialog.2=Datenkeller (mit ':' getrennt)
AM0InputDialog.20=Bitte überprüfe folgende Zahlen:\n
AM0InputDialog.21=Adresse: 
AM0InputDialog.24=Diese Eingabe für den Hauptspeicher ist nicht korrekt.\n
AM0InputDialog.25=Die Adresse darf nicht negtiv oder 0 sein, aber sie war:\n
AM0InputDialog.26=Diese Hauptspeicheradresse ist nicht korrekt.\n
AM0InputDialog.27=\ Bitte überprüfe folgende Adresse:
AM0InputDialog.28=Diese Hauptspeicheradresse ist nicht korrekt.\n
AM0InputDialog.29=\ Die Adresse darf nicht negativ oder 0 sein, aber sie war:\n
AM0InputDialog.3=Hauptspeicher (Adresse, Wert)
AM0InputDialog.4=Eingabeband (mit Kommata getrennt)
AM0InputDialog.43=es muss mindestens eine Zahl 
AM0InputDialog.44=oder mehr mit ',' getrennt eingegeben werden, aber es war:\n
AM0InputDialog.45=Dieses Eingabeband ist nicht korrekt. Es ist nur ein '-' zugelassen und\n
AM0InputDialog.46=es muss mindestens eine Zahl 
AM0InputDialog.47=oder mehr mit ',' getrennt eingegeben werden, aber es war:\n
AM0InputDialog.48=Dieser Datenkeller ist nicht korrekt. Es ist nur ein '-' zugelassen und\n
AM0InputDialog.49=es muss mindestens eine Zahl 
AM0InputDialog.5=Ausgabeband (mit Kommata getrennt)
AM0InputDialog.50=oder mehr mit ',' getrennt eingegeben werden, aber es war:\n
AM0InputDialog.51=Dieser Befehlszähler ist nicht korrekt.\nEr muss >=1 sein, aber es war:\n
AM0InputDialog.52=Der Befehlszähler darf nicht leer sein!\n
AM0InputDialog.6=Wert: 
AM0InputDialog.7=Dieses Ausgabeband ist nicht korrekt. Es ist nur ein '-' zugelassen und\n
AM0InputDialog.74=Hauptspeicherkonfiguration
AM0InputDialog.8=Diese Adresse existiert bereits. Soll der Wert an dieser Adresse überschrieben werden?
AM0InputDialog.87=Datenkellerkonfiguration
AM0InputDialog.9=Diese Adresse existiert nicht:\n
AM0PagingTableModel.0=Befehlszähler
AM0PagingTableModel.1=Datenkeller
AM0PagingTableModel.10=<html>&nbsp;&nbsp;Zeige Schritte von <b>
AM0PagingTableModel.11=</b> bis <b>
AM0PagingTableModel.12=</b></html>
AM0PagingTableModel.2=Hauptspeicher
AM0PagingTableModel.3=Eingabeband
AM0PagingTableModel.4=Ausgabeband
AM0PagingTableModel.7=<html>&nbsp;&nbsp;Zeige Schritte von <b>
AM0PagingTableModel.8=</b> bis <b>
AM0PagingTableModel.9=</b></html>
AM0Scanner.0=Unbekannter interner Scanner Fehler
AM0Scanner.1=Fehler: konnte Eingabe nicht in Übereinstimmung bringen
AM0Scanner.2=Fehler: Rückgabewert ist zu groß
AtomicTrans.0=Dieser AtomicType ist nicht gültig
AtomicTrans.5=Token muss für AtomicTrans Funktionen NULL sein
AtomicTrans.6=Eine Sprungbefehl muss eine Sprungadresse haben
AtomicTrans.7=Anwenden von AtomicTrans ist nicht erlaubt
BlockTrans.0=blocktrans: W(<Block>) \u2212 \u2192 bProg0\n\n
BlockTrans.1=blocktrans({ decl statseq return 0;}) := stseqtrans(statseq, update(decl, tab \u2205 ), 1)
BlockTrans.2=für alle decl \u2208 W(<Declaration>) und statseq \u2208 W(<StatementSequence>),
BlockTrans.3=tab \u2205 \u2208 Tab mit graph(tab \u2205 ) = \u2205
BoolExpTrans.0=boolexptrans: W(<BoolExpression>) \u00D7 Tab\u2212 \u2192 bProg0\n\n
BoolExpTrans.1=boolexptrans(se 1 rel se 2 , tab) :=\n
BoolExpTrans.2=\tsimpleexptrans(se 1 , tab)\n
BoolExpTrans.3=\tsimpleexptrans(se 2 , tab)\n
BoolExpTrans.4=\tREL;\n
BoolExpTrans.5=für alle se 1 , se 2 \u2208 W(<SimpleExpression>), rel \u2208 {==, \!=, <, >, <=, >=} und tab \u2208 Tab
C0Scanner.0=Fehler: Rückgabewert ist zu groß
C0Scanner.177=Unbekannter interner Scanner Fehler
C0Scanner.178=Fehler: konnte Eingabe nicht in Übereinstimmung bringen
Div.0=Der Datenkeller enthält weniger als zwei Elemente!
Div.1=Division mit 0!
Div.2=Falls <i>d</i>=<i>d</i>.1:<i>d</i>.2:<i>d</i>.3: ... :<i>d</i>.n mit n \u2265 2, dann (<i>m</i>+1,(<i>d</i>.2/<i>d</i>.1):<i>d</i>.3: ... :<i>d</i>.n,<i>h</i>, <i>inp</i>, <i>out</i>)
Editor.3=<p>Die Syntaxüberprüfung war <strong style="color: \#0b780b;">
Editor.4=erfolgreich</strong>. Klicke nun auf <em>Start</em>.</p>
Editor.5=Transformiertes Programm
EditorView.10=AM0-Code
EditorView.12=Konsole
EditorView.13=Optionen
EditorView.14=Editor
EditorView.15=Soll das Programm vor der Transformation gespeichert werden?
EditorView.16=Speichern
EditorView.17=Lädt Code in den Editor
EditorView.18=Speichere den soeben editierten Code.
EditorView.19=Verwende den Code für die Simulation oder Transformation.
EditorView.2=Laden
EditorView.20=Validiere den Code.
EditorView.21=Verwende AM0 Code.
EditorView.22=Verwende C0 Code.
EditorView.23=Zeile: 
EditorView.24=\ Spalte: 
EditorView.25=Neue Datei
EditorView.4=Speichern
EditorView.6=Validiere
EditorView.7=Start
EditorView.9=C0-Code
Equal.0=Der Datenkeller enthält weniger als zwei Elemente!
Equal.1=Falls <i>d</i>=<i>d</i>.1:<i>d</i>.2:<i>d</i>.3: ... :<i>d</i>.n mit n \u2265 2, dann (<i>m</i>+1,b:<i>d</i>.3: ... :<i>d</i>.n,<i>h</i>, <i>inp</i>, <i>out</i>)<br />und <i>b</i>=1, falls <i>d</i>.2=<i>d</i>.1, und <i>b</i>=0, falls <i>d</i>.2\!=<i>d</i>.1,<br />d.h. für den Wert true (oder false) wird 1 (oder 0) auf den Datenkeller gelegt.
ErrorEvents.RemoveThisToken=Entferne es, um diesen Fehler zu beseitigen.
ErrorEvents.LexicalAnalysis=Lexikalische Analyse
ErrorEvents.SyntacticAnalysis=Syntaktische Analyse
ErrorEvents.FollowingErrors=Folgende <strong style="%s">Fehler</strong> traten während der Validierung auf:
ErrorEvents.FollowingError=Folgender <strong style="%s">Fehler</strong> trat während der Validierung auf:
ErrorEvents.NumberTooLarge=Die eingegebene Zahl <code style="%s">%s</code> in Zeile %d, Spalte %d ist zu groß: der maximal erlaubte Wert ist <code>%d</code>.
ErrorEvents.UnexpectedTokenAt=Unerwartetes Terminalsymbol <code style="%s">"%s"</code> in Zeile %d, Spalte %d.
ErrorEvents.DontKnowWhatToDo=Kann die Eingabe <code style="%s">"%s"</code> auf Zeile %d nicht verarbeiten.
ErrorEvents.UnexpectedEOF=Unerwartetes Dateiende in Zeile %d, Spalte %d.
ErrorEvents.UnexpectedEOL=Unerwartetes Zeilenende in Zeile %d, Spalte %d.
ErrorEvents.InsertRelation=Füge eine der Relationen <code>"=="</code>, <code>"!="</code>, <code>"&gt;="</code>, <code>"&lt;="</code>, <code>"&gt;"</code> oder <code>"&lt;"</code> ein, um diesen booleschen Ausdruck zu komplettieren.
ErrorEvents.InsertAmp=Füge "&amp;" ein, um dieses <code>scanf</code>-Statement zu komplettieren.
ErrorEvents.InsertComma=Füge <code>","</code> ein, um diesen Fehler zu beseitigen.
ErrorEvents.InsertAssign=Füge <code>"="</code> ein, um diesen Fehler zu beseitigen.
ErrorEvents.InsertSemicolon=Füge <code>";"</code> ein, um das vorhergehende Statement zu komplettieren.
ErrorEvents.InsertIdent=Füge einen Variablennamen ein, um diesen Fehler zu beseitigen.
ErrorEvents.InsertNumber=Füge eine Zahl ein, um diesen Fehler zu beseitigen.
ErrorEvents.InsertNumber_AM0=Füge eine Zahl ein, um dieses AM0-Statement zu komplettieren.
ErrorEvents.InsertSemicolon_AM0=Füge <code>";"</code> ein, um dieses AM0-Statement zu komplettieren.
GreaterEqual.0=Der Datenkeller enthält weniger als zwei Elemente!
GreaterEqual.1=Falls <i>d</i>=<i>d</i>.1:<i>d</i>.2:<i>d</i>.3: ... :<i>d</i>.n mit n \u2265 2, dann (<i>m</i>+1,b:<i>d</i>.3: ... :<i>d</i>.n,<i>h</i>, <i>inp</i>, <i>out</i>)<br />und <i>b</i>=1, wenn <i>d</i>.2\u2265<i>d</i>.1, und <i>b</i>=0, wenn <i>d</i>.2<<i>d</i>.1,<br />d.h. für den Wert true (oder false) wird 1 (oder 0) auf den Datenkeller gelegt.
GreaterThen.0=Der Datenkeller enthält weniger als zwei Elemente!
GreaterThen.1=Falls <i>d</i>=<i>d</i>.1:<i>d</i>.2:<i>d</i>.3: ... :<i>d</i>.n mit n \u2265 2, dann (<i>m</i>+1,b:<i>d</i>.3: ... :<i>d</i>.n,<i>h</i>, <i>inp</i>, <i>out</i>)<br />und <i>b</i>=1, wenn <i>d</i>.2><i>d</i>.1, und <i>b</i>=0, wenn <i>d</i>.2\u2264<i>d</i>.1,<br />d.h. für den Wert true (oder false) wird 1 (oder 0) auf den Datenkeller gelegt.
JEditor.0=Eingabe/Ausgabe Fehler
JEditor.1=AM0 Programm (*.am0)
JEditor.13=Eingabe/Ausgabe Fehler
JEditor.3=C0 Programm (*.c0)
JEditor.8=Der Programmcode wurde modifiziert.\nMöchtest du ihn speichern?
JEditor.9=Bestätigen
Jmc.0=Der Datenkeller enthält kein Element!
Jmc.1=Falls <i>d</i>=0:<i>d</i>.2: ... :<i>d</i>.n mit n \u2265 1, dann (<i>e</i>,<i>d</i>.2: ... :<i>d</i>.n,<i>h</i>, <i>inp</i>, <i>out</i>)<br />sonst (<i>m</i>+1,<i>d</i>.2: ... :<i>d</i>.n,<i>h</i>, <i>inp</i>, <i>out</i>)<br />Falls das erste Datenkellerelement 0 (logisch falsch) ist wird der PC auf <i>e</i> gesetzt.<br />Sonst wird er inkrementiert.
Jmp.0=(<i>e</i>,<i>d</i>,<i>h</i>, <i>inp</i>, <i>out</i>)
LesserEqual.0=Der Datenkeller enthält weniger als zwei Elemente.
LesserEqual.1=Falls <i>d</i>=<i>d</i>.1:<i>d</i>.2:<i>d</i>.3: ... :<i>d</i>.n mit n \u2265 2, dann (<i>m</i>+1,b:<i>d</i>.3: ... :<i>d</i>.n,<i>h</i>, <i>inp</i>, <i>out</i>)<br />und <i>b</i>=1, wenn <i>d</i>.2\u2264<i>d</i>.1, und <i>b</i>=0, wenn <i>d</i>.2><i>d</i>.1,<br />, d.h. für den Wert True (False) wird 1 (0) auf den Datenkeller gelegt.
LesserThen.0=Der Datenkeller enthält weniger als zwei Elemente.
LesserThen.1=Falls <i>d</i>=<i>d</i>.1:<i>d</i>.2:<i>d</i>.3: ... :<i>d</i>.n mit n \u2265 2, dann (<i>m</i>+1,b:<i>d</i>.3: ... :<i>d</i>.n,<i>h</i>, <i>inp</i>, <i>out</i>)<br />und <i>b</i>=1, wenn <i>d</i>.2<<i>d</i>.1, und <i>b</i>=0, wenn <i>d</i>.2\u2265<i>d</i>.1,<br />, d.h. für den Wert True (False) wird 1 (0) auf den Datenkeller gelegt.
Lit.0=(<i>m</i>+1,<i>z</i>:<i>d</i>,<i>h</i>, <i>inp</i>, <i>out</i>)
Load.0=Diese Hauptspeicherzelle ist nicht definiert.
Load.1=Falls <i>h</i>(<i>n</i>) \u220A \u2115, dann (<i>m</i>+1,<i>h</i>(<i>n</i>):<i>d</i>,<i>h</i>, <i>inp</i>, <i>out</i>)
Mod.0=Der Datenkeller enthält weniger als zwei Elemente.
Mod.1=Falls <i>d</i>=<i>d</i>.1:<i>d</i>.2:<i>d</i>.3: ... :<i>d</i>.n mit n \u2265 2, dann (<i>m</i>+1,(<i>d</i>.2%<i></i>.1):<i>d</i>.3: ... :<i>d</i>.n,<i>h</i>, <i>inp</i>, <i>out</i>)
ModuleInfo.2=Franz Gregor, Martin Morgenstern,\n
ModuleInfo.3=\ Max Leuth\u00E4user, David Voigt, Felix Schmitt
ModuleInfo.5=Dieses Modul übersetzt schrittweise C0- in AM0-Programme und simuliert AM0-Programme.
ModuleInfo.8=GNU General Public License. Grafiken vom Tango Desktop Project.
Mul.0=Der Datenkeller enthält weniger als zwei Elemente.
Mul.1=Falls <i>d</i>=<i>d</i>.1:<i>d</i>.2:<i>d</i>.3: ... :<i>d</i>.n mit n \u2265 2, dann (<i>m</i>+1,(<i>d</i>.2*<i>d</i>.1):<i>d</i>.3: ... :<i>d</i>.n,<i>h</i>, <i>inp</i>, <i>out</i>)
NotEqual.0=Der Datenkeller enthält weniger als zwei Elemente.
NotEqual.1=Falls <i>d</i>=<i>d</i>.1:<i>d</i>.2:<i>d</i>.3: ... :<i>d</i>.n mit n \u2265 2, dann (<i>m</i>+1,b:<i>d</i>.3: ... :<i>d</i>.n,<i>h</i>, <i>inp</i>, <i>out</i>)<br />und <i>b</i>=1, wenn <i>d</i>.2\!=<i>d</i>.1, und <i>b</i>=0, wenn <i>d</i>.2=<i>d</i>.1,<br />, d.h. für den Wert True (False) wird 1 (0) auf den Datenkeller gelegt.
PresentationAction.0=Präsentationsmodus
Read.0=Ziel < 0 ist nicht erlaubt\!
Read.1=Das Eingabeband ist leer\!
Read.2=Falls <i>inp</i>=<i>first</i>(<i>inp</i>).<i>rest</i>(<i>inp</i>), dann (<i>m</i>+1,<i>d</i>,<i>h</i>[<i>n</i>/<i>first</i>(<i>inp</i>)], <i>rest</i>(<i>inp</i>), <i>out</i>)<br />und für jedes <i>n</i> \u220A \u2124 und <i>w</i> \u220A \u2124<sup>*</sup>: <i>first</i>(<i>n</i>:<i>w</i>)=<i>n</i> und <i>rest</i>(<i>n</i>:<i>w</i>)=<i>w</i>
SimpleExpTrans.0=simpleexptrans: W(<SimpleExpression>) \u00D7 Tab\u2212 \u2192 bProg0
SimulationView.11=Zurück
SimulationView.13=Weiter
SimulationView.15=Leeren
SimulationView.17=Alles in einem Schritt
SimulationView.19=Initiale Konfiguration
SimulationView.23=<html>Die Simulation wird nach maximal <b>
SimulationView.24=</b> Schritten nachfragen, ob sie weiter laufen soll.<html>
SimulationView.26=<html>Die Simulation wird nach maximal <b>
SimulationView.27=</b> Schritten nachfragen, ob sie weiter laufen soll.<html>
SimulationView.28=\ \ Nachfragen nach: 
SimulationView.29=\ Schritten  
SimulationView.3=AM0-Tabelle
SimulationView.31=Befehls Hilfe
SimulationView.32=Zum Anfang der Simulation springen.
SimulationView.33=Ans Ende der Simulation springen.
SimulationView.34=Zurück zum Editor.
SimulationView.35=Einen Schritt zurück gehen.
SimulationView.36=Einen Schritt weiter gehen.
SimulationView.37=Simulation in einem Schritt.
SimulationView.38=Eine Maschinenkonfiguration eingeben.
SimulationView.39=Alles bereinigen. Diese Aktion wird die aktuelle Maschinenkonfiguration sowie alle Übersetzungsschritte entfernen\!
SimulationView.4=AM0-Animation
SimulationView.5=Tabellenanfang
SimulationView.6=Tabellenende
SimulationView.7=Noch nicht gestartet.  
SimulationView.9=Zum Editor
Simulator.0=Es tratt ein Fehler bei der Simulation auf.\n
Simulator.1=Der folgende Befehl konnte nicht ausgeführt werden:\n
Simulator.10=Letzter Schritt: 
Simulator.12=<html>&nbsp;&nbsp;Zeige Schritte von <b>
Simulator.13=</b> bis <b>
Simulator.14=</b></html>
Simulator.15=\ \ Letzter Schritt: 
Simulator.17=\ \ Letzter Schritt: 
Simulator.19=\ Schritte berechnet.\n
Simulator.20=Möchtest du fortfahren?\n\n
Simulator.21=Wähle 'Nein' zum Stoppen oder 'Ja' zum Fortsetzen der Simulation
Simulator.22=Simulation
Simulator.23=\ \ Letzter Schritt: 
Simulator.25=Noch nicht gestartet.  
Simulator.3=Grund:\n
Simulator.4=Dieser Sprungbefehl konnte nicht ausgeführt werden:\n
Simulator.6=Grund:\n
Store.0=Der Datenkeller enthält kein Element.
Store.1=Falls <i>d</i>=<i>d</i>.1:<i>d'</i>, dann (<i>m</i>+1,<i>d'</i>,<i>h</i>[<i>n</i>/<i>d</i>.1], <i>inp</i>, <i>out</i>)<br /><table><tr><td valign='middle'>und <i>h</i>[<i>n</i>/<i>d</i>.1](<i>k</i>)=</td><td><font size='6'>{</font></td><td><i>d</i>.1<br /><i>h</i>(<i>k</i>)</td><td>wenn k=n<br />sonst</td></tr></table>
STSeqTrans.0=stseqtrans: W(<StatementSequence>) \u00D7 Tab \u00D7 N\u2217 \u2212 \u2192 bProg0\n\n
STSeqTrans.1=stseqtrans(stat 1 stat 2 . . . stat n , tab, a) :=\n
STSeqTrans.2=\tsttrans(stat 1 , tab, a.1)\n
STSeqTrans.3=\tsttrans(stat 2 , tab, a.2)\n
STSeqTrans.4=\t...\n
STSeqTrans.5=\tsttrans(stat n , tab, a.n)\n
STSeqTrans.6=für alle stat 1 , stat 2 , . . . , stat n \u2208 W(<Statement>), tab \u2208 Tab und a \u2208 N\u2217
STSeqTrans.7=Es wurde versucht, eine leere statement sequence zu transformieren.
STTrans.AssignError=Das Symbol auf der linken Seite der Zuweisung existiert nicht oder ist ein Konstantensymbol!
STTrans.ScanfError=Das Symbol in diesem scanf-Statement existiert nicht oder ist ein Konstantensymbol!
STTrans.PrintfError=Das Symbol in diesem printf-Statement existiert nicht oder ist ein Konstantensymbol!
STTrans.0=sttrans: W(<Statement>) \u00D7 Tab \u00D7 N\u2217 \u2212 \u2192 bProg0\n\n
STTrans.1=sttrans({ stat 1 stat 2 . . . stat n }, tab, a) :=\n
STTrans.10=sttrans(printf("%d",id);, tab, a) :=\n
STTrans.11=\twenn tab(id ) = (var, n) dann WRITE n;\n
STTrans.12=\tfür alle id \u2208 W( Ident ), tab \u2208 Tab und a \u2208 N\u2217
STTrans.13=sttrans(if ( exp ) stat, tab, a) :=\n
STTrans.14=\tboolexptrans(exp, tab)\n
STTrans.15=\tJMC a.1;\n
STTrans.16=\tsttrans(stat , tab, a.2)\n
STTrans.17=\ta.1:\n
STTrans.18=\tfür alle exp \u2208 W( BoolExpression ), stat \u2208 W( Statement ), tab \u2208 Tab\n
STTrans.19=\tund a \u2208 N\u2217
STTrans.2=\tstseqtrans(stat 1, stat 2 . . . stat n , tab, a)\n
STTrans.20=sttrans(if ( exp ) stat 1 else stat 2 , tab, a) :=\n
STTrans.21=\tboolexptrans(exp, tab)\n
STTrans.22=\tJMC a.1;\n
STTrans.23=\tsttrans(stat 1 , tab, a.2)\n
STTrans.24=\tJMP a.3;\n
STTrans.25=\ta.1: sttrans(stat 2 , tab, a.4)\n
STTrans.26=\ta.3:\n
STTrans.27=\tfür alle exp \u2208 W( BoolExpression ), stat 1 , stat 2 \u2208 W( Statement ),\n
STTrans.28=\ttab \u2208 Tab und a \u2208 N\u2217
STTrans.29=sttrans(while ( exp ) stat, tab, a) :=\n
STTrans.3=\tfür alle stat 1 , stat 2 , . . . , stat n \u2208 W( statement ), tab \u2208 Tab und a \u2208 N\u2217
STTrans.30=\ta.1 : boolexptrans(exp, tab)\n
STTrans.31=\tJMC a.2;\n
STTrans.32=\tsttrans(stat , tab, a.3)\n
STTrans.33=\tJMP a.1;\n
STTrans.34=\ta.2:\n
STTrans.35=\tfür alle exp \u2208 W( BoolExpression ), stat \u2208 W( Statement ), tab \u2208 Tab\n
STTrans.36=\tund a \u2208 N\u2217
STTrans.4=sttrans(id = exp;, tab, a) :=\n
STTrans.5=\twenn tab(id ) = (var, n) dann simpleexptrans(exp, tab) STORE n;
STTrans.6=\tfür alle id \u2208 W( Ident ), exp \u2208 W( SimpleExpression ), tab \u2208 Tab und a \u2208 N\u2217
STTrans.7=sttrans(scanf("%i",&id);, tab, a) :=\n
STTrans.8=\twenn tab(id ) = (var, n) dann READ n;\n
STTrans.9=\tfür alle id \u2208 W( Ident ), tab \u2208 Tab und a \u2208 N\u2217
Symbol.0=Ungültige Speicheradresse < 
Symbol.1=Der Zugriff auf Adressen von Konstanten ist ungültig.
SymbolTable.0=Ein symbol mit id
SymbolTable.1=\ existiert bereits.
SymbolTable.10=Es wurde versucht, den Wert eines nicht existierenden Symbols auszulesen
SymbolTable.11=Es wurde versucht, den SymbolType eines nicht existierenden Symbols auszulesen
SymbolTable.2=Eine Variable it Speicheradresse 
SymbolTable.3=\ existiert bereits
SymbolTable.9=Es wurde versucht, den SymbolType eines nicht existierenden Symbols auszulesen
Trans.0=trans: W(<Program>) \u2212 \u2192 bProg0\n\n
Trans.1=trans( \#include <stdio.h> int main() block ) := blocktrans(block) für alle block \u2208 W(<Block>)
TransformationView.0=Typ
TransformationView.1=ID
TransformationView.10=Anwenden
TransformationView.12=Fertig transformieren
TransformationView.14=Simulieren
TransformationView.16=Zurück zum Editor
TransformationView.18=Definition / Regel
TransformationView.19=Vorschau
TransformationView.2=Adresse
TransformationView.25=Wollen Sie das transformatierte Programm an den Editor schicken?
TransformationView.26=übertrage
TransformationView.3=tab(ID)
TransformationView.32=Fehler
TransformationView.33=Alle anwenden ist im Zustand FINISHED nicht möglich. Internal program error\!
TransformationView.34=Fehler
TransformationView.35=Fehler
TransformationView.4=Fehler
TransformationView.40=Zurück zum Editor.
TransformationView.41=Den letzten Schritt rückgängig machen.
TransformationView.42=Die ausgewählte Transformationsfunktion anwenden.
TransformationView.43=In einem Schritt übersetzen.
TransformationView.44=Übertrage das übersetzte Programm zum Simulator.
TransformationView.5=Fehler
TransformationView.6=Fehler
TransformationView.8=Rückgängig
Transformator.0=Fehler
Transformator.1=Diese Funktion kann nicht weiter transformiert werden, sie ist bereits atomar.
Transformator.11=Fehler
Transformator.12=Die Transformation wurde erfolgreich abgeschlossen.
Transformator.13=Transformation abgeschlossen
Transformator.15=Dieser Index zeigt auf eine nicht anwendbare Transformationsfunktion.\n
Transformator.2=Ungültige Transformation
Transformator.3=Keine Transformationsfunktion am Index 
Transformator.5=Diese Funktion kann nicht weiter transformiert werden, sie ist bereits atomar.
Transformator.6=Ungültige Transformation
Transformator.7=Fehler
Transformator.8=Die Transformation wurde erfolgreich abgeschlossen.
Transformator.9=Transformation abgeschlossen
TransformFunction.0=abstrakte transformationsfunktion
Write.0=Diese Ramzelle ist nicht definiert!
Write.1=Falls <i>h</i> \u220A \u2124, dann (<i>m</i>+1,<i>d</i>,<i>h</i>, <i>inp</i>, <i>out</i>:<i>h</i>(<i>n</i>))
Sub.0=Der Datenkeller enthält weniger als zwei Elemente!
Sub.1=Falls <i>d</i>=<i>d</i>.1:<i>d</i>.2:<i>d</i>.3: ... :<i>d</i>.n mit n \u2265 2 dann (<i>m</i>+1,(<i>d</i>.2-<i>d</i>.1):<i>d</i>.3: ... :<i>d</i>.n,<i>h</i>, <i>inp</i>, <i>out</i>)
