/*
 * j-Algo - j-Algo is an algorithm visualization tool, especially useful for
 * students and lecturers of computer science. It is written in Java and platform
 * independent. j-Algo is developed with the help of Dresden University of
 * Technology.
 * 
 * Copyright (C) 2004-2010 j-Algo-Team, j-algo-development@lists.sourceforge.net
 * 
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place, Suite 330, Boston, MA 02111-1307 USA
 */
/* WARNING: This is generated code. DO *NOT* MODIFY IT! */

package org.jalgo.module.am0c0.parser.am0;

import java.util.ArrayList;
import org.jalgo.module.am0c0.model.LineAddress;
import org.jalgo.module.am0c0.parser.ParserUtils;
import beaver.*;
import org.jalgo.module.am0c0.model.am0.*;
import org.jalgo.module.am0c0.parser.ErrorEvents;
import org.jalgo.module.am0c0.model.AddressException;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "am0-parser.g".
 */
public class GeneratedAM0Parser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short SEMICOLON = 1;
		static public final short NUMBER = 2;
		static public final short EOL = 3;
		static public final short ADD = 4;
		static public final short MUL = 5;
		static public final short SUB = 6;
		static public final short DIV = 7;
		static public final short MOD = 8;
		static public final short EQ = 9;
		static public final short NE = 10;
		static public final short LT = 11;
		static public final short GT = 12;
		static public final short LE = 13;
		static public final short GE = 14;
		static public final short JMP = 15;
		static public final short JMC = 16;
		static public final short LOAD = 17;
		static public final short STORE = 18;
		static public final short LIT = 19;
		static public final short WRITE = 20;
		static public final short READ = 21;
		static public final short MINUS = 22;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9oLqGbB0b4KXk5lHjjjDHjJsnUYeB35iYIAecYXA8h#Jl#sVT$BFBqZ8qWas0pFEOSxXxl" +
		"CbNIYMjMfNWrgL9CYQbQBMjMcTdMgIt4brAU1gdg6v9hPcNqhf1GnggGL55QD5InlN$Pf7$" +
		"PkR$PgB$PiJ$Qe3aNjGJrsgHZLlJpYdRg9jtPZ5#gbEbS$yLg3n2iD#$DLt0tpiQDOLJrnr" +
		"f6I2B5kI2wd4ACEjVFdwz7ZSDvILHwT2gFIo2c1$v8dZQ85KnX36jEOmIpcaC4y5f358fQG" +
		"mp9Mi8erh6C3czZ2EBQnWrtiOHy7ECGHZZ7fxuad4cJFp$$bdwUidWXoQUvqaADbFPaWPuE" +
		"S#pMV$yIv4uUxSH4ktaVrt8eylYUANAL#0E9wMni=");

    private LineAddress address(Symbol symbol) {
        try {
            return new LineAddress(Symbol.getLine(symbol.getStart()));
        } catch (AddressException e) {
            return null;
        }
    }

    public ErrorEvents getErrorEvents() {
        return (ErrorEvents) report;
    }

	private final Action[] actions;

	public GeneratedAM0Parser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.RETURN,	// [0] Program = CommandList
			new Action() {	// [1] CommandList = Command.a SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final SimulationStatement a = (SimulationStatement) _symbol_a.value;
					 AM0Program program = new AM0Program(); program.add(a); return new Symbol(program);
				}
			},
			new Action() {	// [2] CommandList = CommandList.a EOL Command.b SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final AM0Program a = (AM0Program) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final SimulationStatement b = (SimulationStatement) _symbol_b.value;
					 a.add(b); return new Symbol(a);
				}
			},
			new Action() {	// [3] Command = ADD.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new Symbol(new Add(address(a)));
				}
			},
			new Action() {	// [4] Command = MUL.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new Symbol(new Mul(address(a)));
				}
			},
			new Action() {	// [5] Command = SUB.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new Symbol(new Sub(address(a)));
				}
			},
			new Action() {	// [6] Command = DIV.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new Symbol(new Div(address(a)));
				}
			},
			new Action() {	// [7] Command = MOD.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new Symbol(new Mod(address(a)));
				}
			},
			new Action() {	// [8] Command = EQ.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new Symbol(new Equal(address(a)));
				}
			},
			new Action() {	// [9] Command = NE.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new Symbol(new NotEqual(address(a)));
				}
			},
			new Action() {	// [10] Command = LT.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new Symbol(new LesserThen(address(a)));
				}
			},
			new Action() {	// [11] Command = GT.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new Symbol(new GreaterThen(address(a)));
				}
			},
			new Action() {	// [12] Command = LE.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new Symbol(new LesserEqual(address(a)));
				}
			},
			new Action() {	// [13] Command = GE.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new Symbol(new GreaterEqual(address(a)));
				}
			},
			new Action() {	// [14] Command = JMP.a UnsignedNumber.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Integer b = (Integer) _symbol_b.value;
					 return new Symbol(new Jmp(address(a), b));
				}
			},
			new Action() {	// [15] Command = JMC.a UnsignedNumber.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Integer b = (Integer) _symbol_b.value;
					 return new Symbol(new Jmc(address(a), b));
				}
			},
			new Action() {	// [16] Command = LOAD.a UnsignedNumber.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Integer b = (Integer) _symbol_b.value;
					 return new Symbol(new Load(address(a), b));
				}
			},
			new Action() {	// [17] Command = STORE.a UnsignedNumber.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Integer b = (Integer) _symbol_b.value;
					 return new Symbol(new Store(address(a), b));
				}
			},
			new Action() {	// [18] Command = LIT.a Number.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Integer b = (Integer) _symbol_b.value;
					 return new Symbol(new Lit(address(a), b));
				}
			},
			new Action() {	// [19] Command = WRITE.a UnsignedNumber.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Integer b = (Integer) _symbol_b.value;
					 return new Symbol(new Write(address(a), b));
				}
			},
			new Action() {	// [20] Command = READ.a UnsignedNumber.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Integer b = (Integer) _symbol_b.value;
					 return new Symbol(new Read(address(a), b));
				}
			},
			new Action() {	// [21] UnsignedNumber = NUMBER.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol a = _symbols[offset + 1];
					 return new Symbol(ParserUtils.safeSymbolToInt(a, (ErrorEvents) report));
				}
			},
			new Action() {	// [22] Number = UnsignedNumber.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Integer a = (Integer) _symbol_a.value;
					 return new Symbol(a);
				}
			},
			new Action() {	// [23] Number = MINUS UnsignedNumber.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Integer a = (Integer) _symbol_a.value;
					 return new Symbol(-a);
				}
			}
		};


        this.report = ErrorEvents.forAm0();
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
